CSRF和XSS的区别：
1、CSRF需要登陆后操作，XSS不需要
2、CSRF是请求页面api来实现非法操作，XSS是向当前页面植入js脚本来修改页面内容。
//来源： https://blog.csdn.net/qq_46658751/article/details/123441204


*********************************************************************************************************
crsf预防方式
*********************************************************************************************************

(1)检测请求来源
根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。

通过 Referer Check，可以检查请求是否来自合法的”源”。

在请求头中有一个Referer字段，Referer记录了发送请求的域名，比如：hack.com向example.com中发送请求，那么Referer就为hack.com，只要在处理请求中做相应的校验就可以中断请求。

(2)加入token校验

crsf之所以能够伪造请求成功，其原因之一在于所有的用户信息放于cookie中；因此可以在每次请求中加入token，然后后台进行校验，如果校验通过则进行处理。

在http请求中以参数的形式加入一个随机产生的token,并在服务器建立一个拦截器来验证这个token,token在用户登录后产生并放入session中，然后每次请求拿出token放到参数里发送给服务端.

(3). 在HTTP头中自定义属性并验证

放在http头中自定义属性中。

（4）. 验证码

这个方案的思路是：每次的用户提交都需要用户在表单中填写一个图片上的随机字符串，厄....这个方案可以完全解决CSRF，但个人觉得在易用性方面似乎不是太好，还有听闻是验证码图片的使用涉及了一个被称为MHTML的Bug，可能在某些版本的微软IE中受影响。

（5）. One-Time Tokens(不同的表单包含一个不同的伪随机值)

在实现One-Time Tokens时，需要注意一点：就是“并行会话的兼容”。如果用户在一个站点上同时打开了两个不同的表单，CSRF保护措施不应该影响到他对任何表单的提交。













*********************************************************************************************************
XSS如何防御？

*********************************************************************************************************

XSS 漏洞是由于对用户提交的数据没有经过严格的过滤处理造成的，所以防御的原则就是不相信用户输入的数据，对输入进行过滤，对输出进行编码。

1、使用XSS Filter(输入检查)：
针对用户提交的数据进行有效的验证，只接收我们规定的长度或内容的提交，过滤掉其他的输入内容。

eg：

表单数据指定值的类型：年龄只能是 int 、name 只能是字母数字等。
过滤或移除特殊的 html 标签：<script>、<iframe>等。
过滤 js 事件的标签：onclick、onerror、onfocus等。

2、html实体
当需要往 HTML 标签之间插入不可信数据的时候，首先要做的就是对不可信数据进行 HTML Entity 编码，在 html 中有些字符对于 HTML 来说是具有特殊意义的，所以这些特殊字符不允许在文本中直接使用，需要使用实体字符。

html 实体的存在是导致 XSS 漏洞的主要原因之一，因此我们需要将实体转化为相应的实体编码。
如下：
<	小于	&lt ;
>	大于	&gt ;


3、Http Only cookie

许多 XSS 攻击的目的就是为了获取用户的 cookie，将重要的 cookie 标记为 http only，这样的话当浏览器向服务端发起请求时就会带上 cookie 字段，但是在脚本中却不能访问 cookie，这样就避免了 XSS 攻击利用 js 的 document.cookie获取 cookie。







*********************************************************************************************************
常用的webpack优化方法
https://blog.csdn.net/LSS2288/article/details/127002870
*********************************************************************************************************


关于webpack优化的方法我将其分为大类，如下：
（1）可以提高webpack打包速度，减少打包时间的优化方法
（2）可以让 Webpack 打出来的包体积更小的优化方法

一、提高 Webpack 打包速度
1、优化Loader搜索范围：resolve extensions exclude

2、cache-loader缓存loader处理结果

3、使用多线程处理打包
受限于Node是单线程运行的，所以 Webpack 在打包的过程中也是单线程的，特别是在执行 Loader 的时候，长时间编译的任务很多，这样就会导致等待的情况。那么我们可以使用一些方法将 Loader 的同步执行转换为并行，这样就能充分利用系统资源来提高打包速度了。

（1）HappyPack
happypack ，快乐的打包。人如其名，就是能够让Webpack把打包任务分解给多个子线程去并发的执行，子线程处理完后再把结果发送给主线程。
（2）thread-loader

thread-loader ，在worker 池(worker pool)中运行加载器loader。把thread-loader 放置在其他 loader 之前， 放置在这个 thread-loader 之后的 loader 就会在一个单独的 worker 池(worker pool)中运行。

4、DllPlugin&DllReferencePlugin
DllPlugin 可以将特定的类库提前打包成动态链接库，在一个动态链接库中可以包含给其他模块调用的函数和数据，把基础模块独立出来打包到单独的动态连接库里，当需要导入的模块在动态连接库里的时候，模块不用再次被打包，而是去动态连接库里获取。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。

这里我们可以先将react、react-dom单独打包成动态链接库，首先新建一个新的webpack配置文件：webpack.dll.js
然后我们需要执行这个配置文件生成依赖文件:
webpack  --config webpack.dll.js  --mode  development
接下来我们需要使用 DllReferencePlugin 将依赖文件引入项目中：
```
const DllReferendePlugin = require('webpack/lib/DllReferencePlugin');
module.exports = {
	//省略其他配置
	...,
	plugins: [
		new DllReferencePlugin({
			//manifest就是之前打包出来的json文件
			manifest: path.join(__dirname, 'dll', 'react.manifest.json')
		})
	]
}
```

5、IgnorePlugin
IgnorePlugin用于忽略某些特定的模块，让 webpack 不把这些指定的模块打包进去。

6、 打包文件分析工具
webpack-bundle-analyzer插件的功能是可以生成代码分析报告，帮助提升代码质量和网站性能。

7、费时分析
speed-measure-webpack-plugin，打包速度测量插件。这个插件可以测量webpack构建速度，可以测量打包过程中每一步所消耗的时间，然后让我们可以有针对的去优化代码。

二、减少 Webpack 打包后的文件体积
1、对图片进行压缩和优化
image-webpack-loader这个loder可以帮助我们对打包后的图片进行压缩和优化，例如降低图片分辨率，压缩图片体积等。

2、删除无用的CSS样式
有时候一些时间久远的项目，可能会存在一些CSS样式被迭代废弃，需要将其剔除掉，此时就可以使用purgecss-webpack-plugin插件，该插件可以去除未使用的CSS，一般与 glob、glob-all 配合使用。

3、以CDN方式加载资源
我们知道，一般常用的类库都会发布在CDN上，因此，我们可以在项目中以CDN的方式加载资源，这样我们就不用对资源进行打包，可以大大减少打包后的文件体积。

4、开启Tree Shaking
Tree-shaking，摇晃树。顾名思义就是当我们摇晃树的时候，树上干枯的没用的叶子就会掉下来。类比到我们的代码中就是将没用的代码摇晃下来,从而实现删除代码中未被引用的代码。

这个功能在webpack4中，当我们将mode设置为production时，会自动进行tree-shaking。

5、开启Scope Hoisting
Scope Hoisting 可以让 Webpack 打包出来的代码文件更小、运行的更快， 它又译作 "作用域提升"，是在 Webpack3 中新推出的功能。

由于最初的webpack转换后的模块会包裹上一层函数,import会转换成require，因为函数会产生大量的作用域，运行时创建的函数作用域越多，内存开销越大。而Scope Hoisting 会分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中去，然后适当地重命名一些变量以防止命名冲突。这个功能在webpack4中，当我们将mode设置为production时会自动开启。

6、按需加载&动态加载
必大家在开发单页面应用项目的时候，项目中都会存在十几甚至更多的路由页面。如果我们将这些页面全部打包进一个文件的话，虽然将多个请求合并了，但是同样也加载了很多并不需要的代码，耗费了更长的时间。那么为了首页能更快地呈现给用户，我们肯定是希望首页能加载的文件体积越小越好，这时候我们就可以使用按需加载，将每个路由页面单独打包为一个文件。在给单页应用做按需加载优化时，一般采用以下原则：

对网站功能进行划分splitChunks，每一类一个chunk

对于首次打开页面需要的功能直接加载，尽快展示给用户,某些依赖大量代码的功能点可以按需加载

被分割出去的代码需要一个按需加载的时机









*********************************************************************************************************
Vue实现组件间通信的七种方式
https://blog.csdn.net/m0_65335111/article/details/127550835
*********************************************************************************************************


1. props / $emit
父组件通过props的方式向子组件传递数据，而通过$emit 子组件可以向父组件通信:

2.ref / $refs
ref：这个属性用在子组件上，它的引用就指向了该子组件的实例，可以通过实例来访问组件的数据和方法；如果在普通的 DOM 元素上使用，引用指向的就是 DOM元素。

3.eventBus(事件总线)
其原理就是：事件订阅发布，eventBus 又称为事件总线，在vue中可以使用它来作为沟通桥梁的概念, 就像是所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件， 所以组件都可以通知其他组件。

EventBus = new Vue()

EventBus.$emit('addition', {
    nums: this.num++
})

EventBus.$on('addition', param =>{
   this.count = this.count + param.num;
})

4.Vuex
Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化.

5.$attrs与 $listeners
现在我们来讨论另一种情况：如果我们给出的组件关系图中A组件与D组件是隔代关系， 那它们之前进行通信有哪些方式呢？

6.$parent / $children
使用$parent可以让组件访问父组件的实例（访问的是上一级父组件的属性和方法）。
使用 $children 可以让组件访问子组件的实例，但是， $children 并不能保证顺序，并且访问的数据也不是响应式的。

7.依赖注入（provide / inject）
这种方式就是vue中依赖注入，该方法用于 父子组件之间 的通信。当然这里所说的父子不一定是真正的父子，也可以是祖孙组件，在层数很深的情况下，可以使用这种方式来进行传值。就不用一层一层的传递数据了。








*********************************************************************************************************
Vue性能优化
https://mp.weixin.qq.com/s/PCmCS46GPc6tt1yb9goNFA
*********************************************************************************************************


1、你都做过哪些Vue的性能优化？（ 统计后的结果 ）

1）编码阶段

尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher；

如果需要使用v-for给每项元素绑定事件时，可使用事件代理只用给父元素绑定一个事件处理函数就够用了；

SPA 页面采用keep-alive缓存组件；

在更多的情况下，使用v-if替代v-show；

key保证唯一；

使用路由懒加载、异步组件；

防抖、节流；

第三方模块按需导入；

长列表滚动到可视区域动态加载；

图片懒加载；



2）用户体验：

骨架屏；

PWA；

还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。



3）SEO优化

预渲染；

服务端渲染SSR；



4）打包优化

压缩代码；

Tree Shaking/Scope Hoisting；

使用cdn加载第三方模块；

多线程打包happypack；

splitChunks抽离公共文件（分块，使最后的小块的体积不会太大，开箱即用的默认情况下，webpack 将根据以下条件自动拆分 chunks：新的 chunk 体积大于 20kb（在进行 min+gz 之前的体积））；

sourceMap优化；

说明：优化是个大工程，会涉及很多方面，这里申请另开一个专栏图片图片图片。(：P)

合理使用web worker优化一些计算










*********************************************************************************************************
四、提高性能的九个技巧
https://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html
*********************************************************************************************************

有一些技巧，可以降低浏览器重新渲染的频率和成本。

第一条是上一节说到的，DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。

第二条，如果某个样式是通过重排得到的（该样式数据的读取会先引起重排，后排后才能读到），那么最好缓存结果。避免下一次用到的时候，浏览器又要重排。

第三条，不要一条条地改变样式，而要通过改变class，或者csstext属性，一次性地改变样式。


// bad
var left = 10;
var top = 10;
el.style.left = left + "px";
el.style.top  = top  + "px";

// good 
el.className += " theclassname";

// good
el.style.cssText += "; left: " + left + "px; top: " + top + "px;";
第四条，尽量使用离线DOM，而不是真实的网面DOM，来改变元素样式。比如，操作Document Fragment对象，完成后再把这个对象加入DOM。再比如，使用 cloneNode() 方法，在克隆的节点上进行操作，然后再用克隆的节点替换原始节点。

第五条，先将元素设为display: none（需要1次重排和重绘），然后对这个节点进行100次操作，最后再恢复显示（需要1次重排和重绘）。这样一来，你就用两次重新渲染，取代了可能高达100次的重新渲染。

第六条，position属性为absolute或fixed的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响。

第七条，只在必要的时候，才将元素的display属性为可见，因为不可见的元素不影响重排和重绘。另外，visibility : hidden的元素只对重绘有影响，不影响重排。

第八条，使用虚拟DOM的脚本库，比如React等。

第九条，使用 window.requestAnimationFrame()、window.requestIdleCallback() 这两个方法调节重新渲染（详见后文）。






*********************************************************************************************************
js性能优化
https://blog.csdn.net/lin_fightin/article/details/124521366
*********************************************************************************************************
js代码优化
慎用全局变量：全局变量定义在全局执行上下文，是所有作用域的顶端，而且全局上下文会一直存在上下文执行栈，直到程序退出，还会导致局部变量遮蔽污染。
缓存全局变量，比如缓存dom节点，避免频繁获取
通过原型新增方法
避免属性访问方法使用，就是对象直接获取属性就行，不用封装方法获取属性。
for循环遍历的时候，如果是多次用到了数组的长度，可以提前使用变量保存，不用每次循环都去获取。
遍历一个数组，forEach的性能比for和for in好。优化后的for(数组长度提前读取)的性能比for in好。
节点添加优化，使用文档碎片(document.createDocumentFragment)添加节点，等节点添加完毕之后再统一加入到dom上。
克隆节点比创建节点性能更高
直接量替换Object操作，比如数组，const a = [1,2,3]替换const a = new Array(1,2,3)
减少判断层级，if else中，退出的情况应该放在最前判断，复杂层级深的情况应该放在最后
减少作用域链查找层级
减少数据读取次数，比如dom读取，可以先缓存。
减少声明及语句数
采用事件委托代替多个事件注册。
合理使用web worker优化一些计算

*********************************************************************************************************
https://github.com/sisterAn/JavaScript-Algorithms/issues/152
*********************************************************************************************************
尽量减少 HTTP 请求个数——须权衡
使用 CDN（内容分发网络）
为文件头指定 Expires 或 Cache-Control ，使内容具有缓存性。
避免空的 src 和 href
使用 gzip 压缩内容
把 CSS 放到顶部
把 JS 放到底部
避免使用 CSS 表达式
将 CSS 和 JS 放到外部文件中，（再次请求时可命中304缓存）
减少 DNS 查找次数
精简 CSS 和 JS
避免跳转
剔除重复的 JS 和 CSS
配置 ETags（让已经请求过的资源再次请求时如果没有过期失效，可命中304缓存）
使 AJAX 可缓存
尽早刷新输出缓冲
使用 GET 来完成 AJAX 请求
延迟加载、按需加载
预加载
减少 DOM 元素个数
根据域名划分页面内容
尽量减少 iframe 的个数
避免 404
减小 Cookie 的大小
使用无 cookie 的域
减少 DOM 访问
开发智能事件处理程序（addEventListener）
用 代替 @import
避免使用滤镜
优化图像、压缩图像
优化 CSS Spirite
不要在 HTML 中缩放图像——须权衡
favicon.ico要小而且可缓存
保持单个内容小于25K
打包组件成复合文本
合理使用web worker优化一些计算




*********************************************************************************************************
4、如何优化首页加载，减少白屏时间
https://www.cnblogs.com/baoxinyu/p/16835161.html
*********************************************************************************************************
1-1) DNS预解析 -- 使用 meta 标签

<meta http-equiv="x-dns-prefetch-control" content="on" />
1-2) DNS预解析 -- 使用 link 标签

<link rel="dns-prefetch" href="https://www.baidu.com" />
2）使用 HTTP2

HTTP2 相比于 HTTP1，解析速度更快；支持多路复用，多个请求可以共用一个 TCP 连接；提供了首部压缩功能；支持服务器推送，服务器可以在发送 HTML 页面时，主动推送其他资源，而不用等到浏览器解析到相应位置发请求再响应。

3）减少 HTTP 请求数量，减少 单个HTTP 请求的大小

4）合并、压缩文件；按需加载代码，减少冗余代码

5）采用 svg 图片或字体图标(Iconfont)（一般它们比图片的体积小）

6）使用 Defer 加载 JS

尽量将 CSS 放文件头部，JS 文件放在底部，以免堵塞渲染。JS 如果放在头部，给 script 标签加上 defer 属性，异步下载，延迟执行。

7）服务端渲染
客户端渲染：获取 HTML 文件，根据需要下载 JavaScript 文件并运行，生成 DOM，然后再渲染。

服务端渲染：服务端返回 HTML 文件，客户端只需解析 HTML。

优点：首屏渲染快，对搜索引擎优化（SEO）好。

缺点：配置麻烦，增加了服务器的计算压力。

8）静态资源使用 内容分发网络（CDN）

9）资源缓存，不重复加载相同的资源（图片，字体，文件等资源尤其是需要缓存）

10）图片优化（雪碧图、图片懒加载、CSS 图片懒加载）

11）【这是我自己写的！！！】合并、压缩、去除重复、去除未使用的（CSS、JS）代码

12）代码拆分。code split、动态import

13）多页面+单页面组合，不是整个网站都是同一个页面切换前端路由，酌情拆分一些其他页面作为新页面

14）优化冷启动时间，使用prefetch (还可以：使用Quicklink（阿里的），在网速好的时候 可以帮助你预加载页面资源)

// 上面靠近底部的几条来源地址： https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/234






*********************************************************************************************************
2 css 怎么开启硬件加速(GPU 加速)
https://blog.csdn.net/m0_60719784/article/details/120219321
*********************************************************************************************************
浏览器在处理下面的 css 的时候，会使用 GPU 渲染

transform（当 3D 变换的样式出现时会使用 GPU 加速）
opacity
filter
will-change


4 css 的渲染层合成是什么 浏览器如何创建新的渲染层

在 DOM 树中每个节点都会对应一个渲染对象（RenderObject），当它们的渲染对象处于相同的坐标空间（z 轴空间）时，就会形成一个 RenderLayers，也就是渲染层。渲染层将保证页面元素以正确的顺序堆叠，这时候就会出现层合成（composite），从而正确处理透明元素和重叠元素的显示。对于有位置重叠的元素的页面，这个过程尤其重要，因为一旦图层的合并顺序出错，将会导致元素显示异常。







*********************************************************************************************************
web 性能优化
file:///E:/%E9%9D%A2%E8%AF%95%E9%A2%98---%E5%9F%BA%E7%A1%80%E9%A2%98---%E5%85%AB%E8%82%A1%E6%96%87/2022%E5%B9%B4%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E8%AF%95%E9%A2%98.pdf
*********************************************************************************************************
参考回答：
降低请求量：合并、压缩资源，减少 HTTP 请求数，minify / gzip 压缩，lazyLoad， 按需加载。
加快请求速度：预解析 DNS，减少域名数，避免（多次）跳转（须均衡考虑），并行加载，CDN 分发。
缓存：HTTP 协商缓存请求，离线缓存 manifest，离线数据缓存 localStorage。
渲染：JS/CSS 优化，加载顺序，服务端渲染，pipeline。
体验： 增加lodaing、骨架屏









*********************************************************************************************************
https://developer.mozilla.org/zh-CN/docs/Web/Performance/dns-prefetch
*********************************************************************************************************

第三，考虑将 dns-prefetch 与 preconnect(预连接)提示配对。尽管 dns-prefetch 仅执行 DNS 查找，但preconnect 会建立与服务器的连接。如果站点是通过 HTTPS 服务的，则此过程包括 DNS 解析，建立 TCP 连接以及执行 TLS 握手。将两者结合起来可提供进一步减少跨域请求的感知延迟的机会。您可以安全地将它们一起使用，如下所示：

<link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin>
<link rel="dns-prefetch" href="https://fonts.gstatic.com/">

备注： 如果页面需要建立与许多第三方域的连接，则将它们预先连接会适得其反。 preconnect 提示最好仅用于最关键的连接。对于其他的，只需使用 <link rel="dns-prefetch"> 即可节省第一步的时间-DNS 查找。



