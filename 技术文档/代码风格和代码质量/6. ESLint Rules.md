# 6. ESLint Rules

所有的规则默认都是禁用的。在配置文件中，使用 "extends": "eslint:recommended" 来启用推荐的规则，报告一些常见的问题，在下文中这些推荐的规则都带有一个 <span style="color:green;">**&radic;**</span> （绿色加粗对号） 标记。

命令行的 --fix 选项用来自动修复规则所报告的问题（目前，大部分是对空白的修复），在[规则页面](https://eslint.bootcss.com/docs/rules/)中会有一个扳手的图标。

# Rules ：代码中可能的错误相关的规则

**_以下仅解释 eslint: recommended 代表的相关规则集合；_**

### 1. for-direction （强制 “for” 循环中更新子句的计数器朝着正确的方向移动）

#### Rule Details （规则的详情）

如果一个 for 循环的停止条件永远无法到达，比如，计数器在错误的方向上移动，将陷入无限循环。当存在这样的无限循环时，惯例是改用 while 循环。更典型的是，无限循环是个 bug。

> 错误 代码示例：

```
/*eslint for-direction: "error"*/
for (var i = 0; i < 10; i--) {
}

for (var i = 10; i >= 0; i++) {
}
```

> 正确 代码示例：

```
/*eslint for-direction: "error"*/
for (var i = 0; i < 10; i++) {
}
```

### 2. getter-return （强制 getter 函数中出现 return 语句）

#### Rule Details （规则的详情）：该规则旨在属性 getter 中出现 return 语句。

该规则期望每个 getter 函数都有返回值。
get 语法将对象属性绑定到一个函数，该函数在查找该属性时将被调用。这是首次在 ECMAScript 5 中引入：

```
// 用法一：
 let p = {
    get name(){
        return "nicholas";
    }
};
// 用法二：
Object.defineProperty(p, "age", {
    get: function (){
        return 17;
    }
});
```

**如果你的项目不使用 ES5 属性 getter，你不需要使用此规则。**

> **错误 代码示例**：

```
/*eslint getter-return: "error"*/

let p = {
    get name(){
        // no returns.
    }
};

Object.defineProperty(p, "age", {
    get: function (){
        // no returns.
    }
});

class P{
    get name(){
        // no returns.
    }
}
```

> **正确 代码示例**：

```
/*eslint getter-return: "error"*/

let p = {
    get name(){
        return "nicholas";
    }
};

Object.defineProperty(p, "age", {
    get: function (){
        return 18;
    }
});

class P{
    get name(){
        return "nicholas";
    }
}
```

#### Options

该规则有一个对象选项：
"allowImplicit": false (默认) 。此时，禁止在 return 语句中隐式地返回 undefined。
当你把选项设置改为 { "allowImplicit": true } 时 正确 代码示例：

```
/*eslint getter-return: ["error", { allowImplicit: true }]*/
let p = {
    get name(){
        return; // return undefined implicitly.
    }
};
```

### 3. no-async-promise-executor （禁止使用异步函数作为 Promise executor）

#### Rule Details （规则的详情）：此规则旨在禁止使用异步的 Promise executor 函数。

解释： new Promise 构造函数接收一个 executor 函数作为参数，该函数具有 resolve 和 reject 两个参数，可用于控制创建的 Promise 的状态。例如：

```
const result = new Promise(function executor(resolve, reject) {
  readFile('foo.txt', function(err, result) {
    if (err) {
      reject(err);
    } else {
      resolve(result);
    }
  });
});
```

executor 函数也可以是 async function。然而，这通常是一个错误，原因如下:

1. 如果异步 executor 函数抛出一个错误，这个错误将会丢失，并且不会导致新构造的 Promise 被拒绝。这可能使会调试和处理一些错误变得困难。
2. 如果一个 Promise executor 函数使用了 await，这通常表示实际上没有必要使用 new Promise 构造函数，或者可以减小 new Promise 构造函数的作用域。
    > **错误 代码示例**：

```
const foo = new Promise(async (resolve, reject) => {
  readFile('foo.txt', function(err, result) {
    if (err) {
      reject(err);
    } else {
      resolve(result);
    }
  });
});

const result = new Promise(async (resolve, reject) => {
  resolve(await foo);
});
```

> **正确 代码示例**：

```
const foo = new Promise((resolve, reject) => {
  readFile('foo.txt', function(err, result) {
    if (err) {
      reject(err);
    } else {
      resolve(result);
    }
  });
});

const result = Promise.resolve(foo);
```

### 4. no-compare-neg-zero （禁止与 -0 进行比较）

该规则对试图与 -0 进行比较的代码发出警告，因为并不会达到预期。也就是说像 x === -0 的代码对于 +0 和 -0 都有效。推荐作者使用 Object.is(x, -0)。

> **错误 代码示例**：

```
if (x === -0) {
    // doSomething()...
}
Examples of correct code for this rule:
```

> **正确 代码示例**：

```
if (x === 0) {
    // doSomething()...
}

if (Object.is(x, -0)) {
    // doSomething()...
}
```

### 5. no-cond-assign （禁止条件表达式中出现赋值操作符）

在条件语句中，很容易将一个比较运算符（像 ==）错写成赋值运算符（如 =）。

#### Rule Details

该规则禁止在 if、for、while 和 do...while 语句中出现模棱两可的赋值操作符。

#### Options

该规则有一个字符串选项：

-   "except-parens" (默认) 允许条件语句中出现赋值操作符，前提是它们被圆括号括起来 (例如，在 while 或 do...while 循环条件中，允许赋值给一个变量)
-   "always" 禁止条件语句中出现赋值语句;

举例：

```
1.  /*eslint no-cond-assign: "error"*/
2.  /*eslint no-cond-assign: ["error", "always"]*/
```

### 6. no-constant-condition (禁止在条件中使用常量表达式)

将一个常量表达式（比如，一个字面值）作为一个测试的判断条件可能是个书写错误或者为了触发某个特定的行为。例如，下面的代码看起来像是没有准备好发布的。

```
if (false) {
    doSomethingUnfinished();
}
```

#### Rule Details

该规则禁止在以下语句的条件中出现常量表达式：

-   if、for、while 或 do...while 语句
-   ?: 三元表达式

#### Options

选项：checkLoops, **默认为 true**。设置该选项为 false 允许在循环中使用常量表达式。

> **错误 代码示例**：

```
/*eslint no-constant-condition: "error"*/

if (false) {
    doSomethingUnfinished();
}

if (void x) {
    doSomethingUnfinished();
}

for (;-2;) {
    doSomethingForever();
}

while (typeof x) {
    doSomethingForever();
}

do {
    doSomethingForever();
} while (x = -1);

var result = 0 ? a : b;
```

> **正确 代码示例**：

```
/*eslint no-constant-condition: "error"*/

if (x === 0) {
    doSomething();
}

for (;;) {
    doSomethingForever();
}

while (typeof x === "undefined") {
    doSomething();
}

do {
    doSomething();
} while (x);

var result = x !== 0 ? a : b;
```

### 7. no-control-regex (禁止在正则表达式中使用控制字符)

在 ASCII 中，0-31 范围内的控制字符是特殊的、不可见的字符。这些字符很少被用在 JavaScript 字符串中，所以一个正则表达式如果包含这些字符的，很有可能一个错误。

#### Rule Details

该规则禁止在正则表达式中出现控制字符。

> **错误 代码示例**：

```
/*eslint no-control-regex: "error"*/

var pattern1 = /\x1f/;
var pattern2 = new RegExp("\x1f");
```

> **正确 代码示例**：

```
/*eslint no-control-regex: "error"*/

var pattern1 = /\x20/;
var pattern2 = new RegExp("\x20");
```

#### When Not To Use It

如果你需要使用控制字符进行模式匹配，你应该关闭该规则。

### 8. no-debugger (禁用 debugger)

debugger 语句用于告诉 JavaScript 执行环境停止执行并在代码的当前位置启动调试器。随着现代调试和开发工具的出现，使用调试器已不是最佳实践。产品代码不应该包含 debugger，因为它会导致浏览器停止执行代码并打开一个适当的调试器。尤其是生产环境下，更不应该出现 debugger。

#### Rule Details

该规则禁止 debugger 语句。

> **错误 代码示例**：

```
/*eslint no-debugger: "error"*/

function isTruthy(x) {
    debugger;
    return Boolean(x);
}
```

> **正确 代码示例**：

```
/*eslint no-debugger: "error"*/

function isTruthy(x) {
    return Boolean(x); // set a breakpoint at this line
}
```

#### When Not To Use It

如果你的代码在很大程度上仍处于开发阶段，不想剥离 debugger 语句，那么就关闭此规则。通常在部署代码之前，你会禁用 debugger。

### 9. no-dupe-args (禁止在 function 定义中出现重复的参数)

#### Rule Details

如果在一个函数定义中出现多个同名的参数，后面出现的会覆盖前面出现的参数。重复的名称可能是一个打字错误。
该规则禁止在函数定义或表达中出现重名参数。该规则并不适用于箭头函数或类方法，因为解析器会报告这样的错误。

如果 ESLint 在严格模式下解析代码，解析器（不是该规则）将报告这样的错误。

### 10. no-dupe-keys (禁止在对象字面量中出现重复的键)

#### Rule Details

该规则禁止在对象字面量中出现重复的键。
在你的应用程序中，如果对象字面量中出现多个属性有同样的键可能会到导致意想不到的情况出现。

> **错误 代码示例**：

```
/*eslint no-dupe-keys: "error"*/

var foo = {
    bar: "baz",
    bar: "qux"
};

var foo = {
    "bar": "baz",
    bar: "qux"
};

var foo = {
    0x1: "baz",
    1: "qux"
};
```

> **正确 代码示例**：

```
/*eslint no-dupe-keys: "error"*/

var foo = {
    bar: "baz",
    quxx: "qux"
};
```

### 11. no-duplicate-case (禁止在 switch 语句中重复 case 标签)

如果一个 switch 语句中的 case 子句中出现重复的测试表达式，那么很有可能是某个程序员拷贝了一个 case 子句但忘记了修改测试表达式。

#### Rule Details

该规则禁止在 switch 语句中的 case 子句中出现重复的测试表达式。

> **错误 代码示例**：

```
/*eslint no-duplicate-case: "error"*/

var a = 1,
    one = 1;

switch (a) {
    case 1:
        break;
    case 2:
        break;
    case 1:         // duplicate test expression
        break;
    default:
        break;
}

switch (a) {
    case one:
        break;
    case 2:
        break;
    case one:         // duplicate test expression
        break;
    default:
        break;
}

switch (a) {
    case "1":
        break;
    case "2":
        break;
    case "1":         // duplicate test expression
        break;
    default:
        break;
}
```

### 12. no-empty (禁止空块语句)

空语句块，如果不是技术上的错误，通常是由于不完整的重构造成的。

#### Rule Details

该规则禁止在 switch 语句中的 case 子句中出现重复的测试表达式。
该规则禁止空语句块出现。该规则忽略包含一个注释的语句块（例如，在 try 语句中，一个空的 catch 或 finally 语句块意味着程序应该继续执行，无论是否出现错误）。

> **错误 代码示例**：

```
/*eslint no-empty: "error"*/

if (foo) {
}

while (foo) {
}

switch(foo) {
}

try {
    doSomething();
} catch(ex) {

} finally {

}
```

> **正确 代码示例**：

```
/*eslint no-empty: "error"*/

if (foo) {
    // empty
}

while (foo) {
    /* empty */
}

try {
    doSomething();
} catch (ex) {
    // continue regardless of error
}

try {
    doSomething();
} finally {
    /* continue regardless of error */
}
```

#### Options

该规则有例外情况，是个对象：

"allowEmptyCatch": true 允许出现空的 catch 子句 (也就是说，不包含注释)
当你把选项设置改为 { "allowEmptyCatch": true } 时 正确 代码示例：

```
/* eslint no-empty: ["error", { "allowEmptyCatch": true }] */
try {
    doSomething();
} catch (ex) {}

try {
    doSomething();
}
catch (ex) {}
finally {
    /* continue regardless of error */
}
```

#### When Not To Use It

如果你打算使用空语句块，那么你可以禁用此规则。

### 13. no-empty-character-class (禁止在正则表达式中出现空字符集)

在正则表达式中空字符集不能匹配任何字符，它们可能是打字错误。例如：

```
var foo = /^abc[]/;
```

#### Rule Details

该规则禁止在正则表达式中出现空字符集。

> **错误 代码示例**：

```
/*eslint no-empty-character-class: "error"*/

/^abc[]/.test("abcdefg"); // false
"abcdefg".match(/^abc[]/); // null
```

> **正确 代码示例**：

```
/*eslint no-empty-character-class: "error"*/

/^abc/.test("abcdefg"); // true
"abcdefg".match(/^abc/); // ["abc"]

/^abc[a-z]/.test("abcdefg"); // true
"abcdefg".match(/^abc[a-z]/); // ["abcd"]
```

#### 该规则的局限：

该规则不会报告**RegExp 构造函数**的字符串参数中空字符集的使用情况。
例如：该规则会报告正确的代码：

```
/*eslint no-empty-character-class: "error"*/

var abcNeverMatches = new RegExp("^abc[]");
```

### 14. no-ex-assign (禁止对 catch 子句中的异常重新赋值)

在 try 语句中的 catch 子句中，如果意外地（或故意地）给异常参数赋值，是不可能引用那个位置的错误的。由于没有 arguments 对象提供额外的方式访问这个异常，对它进行赋值绝对是毁灭性的。

#### Rule Details

该规则禁止对 catch 子句中的异常重新赋值。

> **错误 代码示例**：

```
/*eslint no-ex-assign: "error"*/

try {
    // code
} catch (e) {
    e = 10;
}
```

> **正确 代码示例**：

```
/*eslint no-ex-assign: "error"*/

try {
    // code
} catch (e) {
    var foo = 10;
}
```

### 15. no-extra-boolean-cast (禁止不必要的布尔类型转换)

在上下文中比如 if 语句的测试表达式的结果已经被强制转化成了一个布尔值，再通过双重否定（!!）或 Boolean 转化是不必要的。例如，这些 if 语句是等价的：

```
if (!!foo) {
    // ...
}

if (Boolean(foo)) {
    // ...
}

if (foo) {
    // ...
}
```

**命令行中的 --fix 选项可以自动修复一些该规则报告的问题。**

#### Rule Details

该规则禁止不必要的布尔类型转换。

> **错误 代码示例**：

```
/*eslint no-extra-boolean-cast: "error"*/

var foo = !!!bar;

var foo = !!bar ? baz : bat;

var foo = Boolean(!!bar);

var foo = new Boolean(!!bar);

if (!!foo) {
    // ...
}

if (Boolean(foo)) {
    // ...
}

while (!!foo) {
    // ...
}

do {
    // ...
} while (Boolean(foo));

for (; !!foo; ) {
    // ...
}
```

> **正确 代码示例**：

```
/*eslint no-extra-boolean-cast: "error"*/

var foo = !!bar;
var foo = Boolean(bar);

function foo() {
    return !!bar;
}

var foo = bar ? !!baz : !!bat;
```

### 16. no-extra-semi (禁用不必要的分号)

命令行中的 --fix 选项可以自动修复一些该规则报告的问题。

书写错误和对哪里需要使用分号的误解，会导致出现不必要的分号。虽然在技术上不是个错误，但阅读代码时会引起困惑。

#### Rule Details

该规则禁用不必要的分号。

> **错误 代码示例**：

```
/*eslint no-extra-semi: "error"*/

var x = 5;;

function foo() {
    // code
};
```

> **正确 代码示例**：

```
/*eslint no-extra-semi: "error"*/

var x = 5;

var foo = function() {
    // code
};
```

#### When Not To Use It

如果你有意使用额外的分号，那么你可以禁用此规则。

### 17. no-func-assign (禁止对 function 声明重新赋值)

JavaScript 函数有两种形式：函数声明 function foo() { ... } 或者函数表达式 var foo = function() { ... } 。虽然 JavaScript 解释器可以容忍对函数声明进行覆盖或重新赋值，但通常这是个错误或会导致问题出现。
举例如下：

```
function foo() {}
foo = bar;
```

#### Rule Details

该规则禁止对 function 声明重新赋值。

> **错误 代码示例**：

```
/*eslint no-func-assign: "error"*/

function foo() {}
foo = bar;

function foo() {
    foo = bar;
}

foo = bar;
function foo() {}
```

> **正确 代码示例**：

```
/*eslint no-func-assign: "error"*/

var foo = function () {}
foo = bar;

function foo(foo) { // `foo` is shadowed.
    foo = bar;
}

function foo() {
    var foo = bar;  // `foo` is shadowed.
}
```

#### When Not To Use It

如果你有意使用额外的分号，那么你可以禁用此规则。

### 18. no-inner-declarations (禁止在嵌套的语句块中出现变量或 function 声明)

在 ES6 之前的 JavaScript 中，函数声明只能在程序或另一个函数体的顶层，尽管解析器有时会错误地接受它们。这只适用于函数声明；命名的或匿名的函数表达式是可以出现在任何允许的地方。
举例：

```
// Good
function doSomething() { }

// Bad
if (test) {
    function doSomethingElse () { }
}

function anotherThing() {
    var fn;

    if (test) {

        // Good
        fn = function expression() { };

        // Bad
        function declaration() { }
    }
}
```

可以在任何地方声明变量，甚至是在深层嵌套的语句块中。由于变量声明提升，把声明放在程序或函数体的顶部会使代码更清晰，在任何地方随意声明变量的做法通常是不可取的。注意 let 和 const 声明的变量不会被提升，因此它们不受此规则影响。
举例：

```
/*eslint-env es6*/

// Good
var foo = 42;

// Good
if (foo) {
    let bar1;
}

// Bad
while (test) {
    var bar2;
}

function doSomething() {
    // Good
    var baz = true;

    // Bad
    if (baz) {
        var quux;
    }
}
```

#### Rule Details

该规则要求函数声明和变量声明（可选的）在程序或函数体的顶部。

#### Options

该规则有一个字符串选项：

-   "functions" (默认) 禁止 function 声明出现在嵌套的语句块中

-   "both" 禁止 function 和 var 声明出现在嵌套的语句块中

> **默认选项 "functions" 的 错误 代码示例**：

```
/*eslint no-inner-declarations: "error"*/

if (test) {
    function doSomething() { }
}

function doSomethingElse() {
    if (test) {
        function doAnotherThing() { }
    }
}
```

> **默认选项 "functions" 的 正确 代码示例**：

```
/*eslint no-inner-declarations: "error"*/

function doSomething() { }

function doSomethingElse() {
    function doAnotherThing() { }
}

if (test) {
    asyncCall(id, function (err, data) { });
}

var fn;
if (test) {
    fn = function fnExpression() { };
}
```

> **选项 "both" 的 错误 代码示例**：

```
/*eslint no-inner-declarations: ["error", "both"]*/

if (test) {
    var foo = 42;
}

function doAnotherThing() {
    if (test) {
        var bar = 81;
    }
}
```

> **选项 "both" 的 正确 代码示例**：

```
/*eslint no-inner-declarations: "error"*/
/*eslint-env es6*/

var bar = 42;

if (test) {
    let baz = 43;
}

function doAnotherThing() {
    var baz = 81;
}
```

### 19. no-invalid-regexp (禁止在 RegExp 构造函数中出现无效的正则表达式)

在正则表达式字面量中无效的模式在代码解析时会引起 SyntaxError，但是 RegExp 的构造函数中无效的字符串只在代码执行时才会抛出 SyntaxError。

#### Rule Details

该规则禁止在 RegExp 构造函数中出现无效的正则表达式。

> **错误 代码示例**：

```
/*eslint no-invalid-regexp: "error"*/

RegExp('[')

RegExp('.', 'z')

new RegExp('\\')
```

> **正确 代码示例**：

```
/*eslint no-invalid-regexp: "error"*/

RegExp('.')

new RegExp

this.RegExp('[')
```

#### environments

ECMAScript 6 为 RegExp 构造函数增加了以下标志参数："u" (unicode) 和 "y" (sticky)

你可以在你的 ESLint 配置 中通过设置 ECMAScript 为 6 ，来使这些标志被有效地识别。

```
// in a .eslintrc.js file
{ "env":{ "es6": true } }

```

#### Options

该规则有例外情况，是个对象："allowConstructorFlags", 它是个标志的数组

选项 { "allowConstructorFlags": ["u", "y"] } 的 正确 代码示例：

```
/*eslint no-invalid-regexp: ["error", { "allowConstructorFlags": ["u", "y"] }]*/

new RegExp('.', 'y')

new RegExp('.', 'yu')
```

### 20. no-irregular-whitespace (禁止不规则的空白)

无效的或不规则的空白会导致 ECMAScript 5 解析问题，也会使代码难以调试（类似于混合 tab 和空格的情况）。
各种空白字符可能是由程序员误输入的，比如拷贝或键盘快捷键。例如，在 macOS 按下 Alt + Space，增加了一个不间断空格。
这些空格引起的已知的问题:

-   零宽空格:
    -   不被认为是分隔符，经常被解析为 Unexpected token ILLEGAL
    -   不在现代浏览器中显示，期待使用代码存储软件解决其可视化问题
-   行分隔符
    -   在 JSON 中不是一个有效的字符，会引起解析错误

#### Rule Details

此规则旨在捕获不是正常制表符（tab） 和空格（whitespace）的无效空格。其中一些字符可能会导致现代浏览器出现问题，而其他字符将是一个调试中的可能发现的问题。
此规则不允许使用以下字符，除非选项允许：

```
\u000B - Line Tabulation (\v) - <VT>
\u000C - Form Feed (\f) - <FF>
\u00A0 - No-Break Space - <NBSP>
\u0085 - Next Line
\u1680 - Ogham Space Mark
\u180E - Mongolian Vowel Separator - <MVS>
\ufeff - Zero Width No-Break Space - <BOM>
\u2000 - En Quad
\u2001 - Em Quad
\u2002 - En Space - <ENSP>
\u2003 - Em Space - <EMSP>
\u2004 - Tree-Per-Em
\u2005 - Four-Per-Em
\u2006 - Six-Per-Em
\u2007 - Figure Space
\u2008 - Punctuation Space - <PUNCSP>
\u2009 - Thin Space
\u200A - Hair Space
\u200B - Zero Width Space - <ZWSP>
\u2028 - Line Separator
\u2029 - Paragraph Separator
\u202F - Narrow No-Break Space
\u205f - Medium Mathematical Space
\u3000 - Ideographic Space
```

//上述这些字符的在显示上都是空格或空字符串

#### Options

该规则有例外情况，是个对象

-   "skipStrings": true (默认) 允许在字符串字面量中出现任何空白字符
-   "skipComments": true 允许在注释中出现任何空白字符
-   "skipRegExps": true 允许在正则表达式中出现任何空白字符
-   "skipTemplates": true 允许在模板字面量中出现任何空白字符
-   > **默认 { "skipStrings": true } 选项的错误 代码示例**：

```
/*eslint no-irregular-whitespace: "error"*/

function thing() /*<NBSP>*/{
    return 'test';
}

function thing( /*<NBSP>*/){
    return 'test';
}

function thing /*<NBSP>*/(){
    return 'test';
}

function thing᠎/*<MVS>*/(){
    return 'test';
}

function thing() {
    return 'test'; /*<ENSP>*/
}

function thing() {
    return 'test'; /*<NBSP>*/
}

function thing() {
    // Description <NBSP>: some descriptive text
}

/*
Description <NBSP>: some descriptive text
*/

function thing() {
    return / <NBSP>regexp/;
}

/*eslint-env es6*/
function thing() {
    return `template <NBSP>string`;
}
```

> **默认 { "skipStrings": true } 选项的 正确 代码示例**：

```
/*eslint no-irregular-whitespace: "error"*/

function thing() {
    return ' <NBSP>thing';
}

function thing() {
    return '​<ZWSP>thing';
}

function thing() {
    return 'th <NBSP>ing';
}
```

> **选项 { "skipComments": true } 的 正确 代码示例**：

```
/*eslint no-irregular-whitespace: ["error", { "skipComments": true }]*/

function thing() {
    // Description <NBSP>: some descriptive text
}

/*
Description <NBSP>: some descriptive text
*/
```

> **选项 { "skipRegExps": true } 的 正确 代码示例**：

```
/*eslint no-irregular-whitespace: ["error", { "skipRegExps": true }]*/

function thing() {
    return / <NBSP>regexp/;
}
```

> **选项 { "skipTemplates": true } 的 正确 代码示例**：

```
/*eslint no-irregular-whitespace: ["error", { "skipTemplates": true }]*/
/*eslint-env es6*/

function thing() {
    return `template <NBSP>string`;
}
```

#### When Not To Use It

如果你想在你的应用中使用 tab 和空格之外的空白字符，可以关闭此规则。

### 21. no-misleading-character-class (不允许在字符类语法中出现由多个代码点组成的字符)

[surrogate pair](https://baike.baidu.com/item/surrogate%20pair/16820063?fr=aladdin)
[代码点](https://baike.baidu.com/item/%E7%82%B9%E4%BB%A3%E7%A0%81/22038405?fr=aladdin)
在正则表达式字面量中无效的模式在代码解析时会引起 SyntaxError，但是 RegExp 的构造函数中无效的字符串只在代码执行时才会抛出 SyntaxError。

Unicode 包括由多个代码点组成的字符。RegExp 字符类语法 (/[abc]/) 不能处理由多个代码点组成的字符；这些字符将被分解到每个代码点。例如，❇️ 是由 ❇ (U+2747) 和 VARIATION SELECTOR-16 (U+FE0F)。如果这是正则表达式字符类，它将匹配 ❇ (U+2747) 或 VARIATION SELECTOR-16 (U+FE0F)而不是 ❇️。

此规则报告在字符类语法中包含多个代码点字符的正则表达式。此规则将以下字符视为多个代码点字符：

-   1. 具有组合字符的字符：
       组合字符属于 Mc、Me 和 Mn [Unicode 通用类别](http://www.unicode.org/L2/L1999/UnicodeData.html#General%20Category) 之一。

```
/^[Á]$/u.test("Á") //→ false
/^[❇️]$/u.test("❇️") //→ false
```

-   2. 带有表情符号修饰符的字符：

```
/^[👶🏻]$/u.test("👶🏻") //→ false
/^[👶🏽]$/u.test("👶🏽") //→ false
```

-   3. 一组区域指标符号：

```
// 这个不是大写字母而是Emoji(s)符号, 参考： https://www.emojiall.com/zh-hans/emoji/%F0%9F%87%AF%F0%9F%87%B5

/^[🇯🇵]$/u.test("🇯🇵") //→ false
```

-   4. ZWJ（Zero Width Joiner）连接的字符：

```
// Emoji , 参看：https://emojipedia.org/emoji/%F0%9F%91%A8%E2%80%8D%F0%9F%91%A9%E2%80%8D%F0%9F%91%A6/
// 参看： https://emojipedia.org/emoji/
/^[👨‍👩‍👦]$/u.test("👨‍👩‍👦") //→ false
```

-   5. 没有 Unicode 标志的 Surrogate pair：：

```
/^[👍]$/.test("👍") //→ false

// Surrogate pair is OK if with u flag.
/^[👍]$/u.test("👍") //→ true
```

#### Rule Details

此规则报告在字符类语法中包含多个代码点字符的正则表达式。

> **错误 代码示例**：

```
/*eslint no-misleading-character-class: error */

/^[Á]$/u
/^[❇️]$/u
/^[👶🏻]$/u
/^[🇯🇵]$/u
/^[👨‍👩‍👦]$/u
/^[👍]$/
```

> **正确 代码示例**：

```
/*eslint no-misleading-character-class: error */

/^[abc]$/
/^[👍]$/u
```

#### When Not To Use It

如果不想检查多个代码点字符的 RegExp 字符类语法，可以关闭此规则。

### 22. no-obj-calls (禁止将全局对象当作函数进行调用)

ECMAScript 提供了几个全局对象，旨在直接调用。这些对象由于是大写的（比如 Math 和 JSON）看起来像是构造函数，但是如果你尝试像函数一样执行它们，将会抛出错误。
[ECMAScript 5 规范](https://es5.github.io/#x15.8)明确表示 Math 和 JSON 是不能被作为函数调用的;
[ECMAScript 2015 规范](https://262.ecma-international.org/6.0/#sec-reflect-object) 明确表明 Reflect 不能被作为函数调用;

#### Rule Details

该规则禁止将 Math、JSON 和 Reflect 对象当作函数进行调用。

> **错误 代码示例**：

```
/*eslint no-obj-calls: "error"*/

var math = Math();
var json = JSON();
var reflect = Reflect();
```

> **正确 代码示例**：

```
/*eslint no-obj-calls: "error"*/

function area(r) {
    return Math.PI * r * r;
}
var object = JSON.parse("{}");
var value = Reflect.get({ x: 1, y: 2 }, "x");
```

### 23. no-prototype-builtins (禁止直接使用 Object.prototypes 的内置属性)

在 ECMAScript 5.1 中，新增了 Object.create，它支持使用指定的 [[Prototype]] 创建对象。Object.create(null) 是一种常见的模式，用于创建将用作映射的对象。当假定对象将包含来自 Object.prototype 的属性时，这可能会导致错误。该规则防止直接从一个对象调用某些 Object.prototype 的方法。

此外，对象可以具有自身属性，这些属性可以将 Object.prototype 的内建属性覆盖掉，可能导致意外行为或拒绝服务安全漏洞。例如，web 服务器解析来自客户机的 JSON 输入并直接在结果对象上调用 hasOwnProperty 是不安全的，因为恶意客户机可能发送一个 JSON 值，如 {"hasOwnProperty": 1}，并导致服务器崩溃。

为了避免这种细微的 bug，最好总是从 Object.prototype 调用这些内置方法。例如，foo.hasOwnProperty("bar") 应该替换为 Object.prototype.hasOwnProperty.call(foo, "bar")。

#### Rule Details

该规则禁止直接在对象实例上调用 Object.prototype 的一些方法。

> **错误 代码示例**：

```
/*eslint no-prototype-builtins: "error"*/

var hasBarProperty = foo.hasOwnProperty("bar");

var isPrototypeOfBar = foo.isPrototypeOf(bar);

var barIsEnumerable = foo.propertyIsEnumerable("bar");
```

> **正确 代码示例**：

```
/*eslint no-prototype-builtins: "error"*/

var hasBarProperty = Object.prototype.hasOwnProperty.call(foo, "bar");

var isPrototypeOfBar = Object.prototype.isPrototypeOf.call(foo, bar);

var barIsEnumerable = {}.propertyIsEnumerable.call(foo, "bar");
```

#### When Not To Use It

如果你的代码只接触带有硬编码键的对象，并且你永远不会使用覆盖 Object.prototype 的方法或者不是继承自 Object.prototype 的方法，那么你可能想要关闭此规则。

### 24. no-regex-spaces (禁止正则表达式字面量中出现多个空格)

命令行中的 --fix 选项可以自动修复一些该规则报告的问题。

正则表达式可以很复杂和难以理解，这就是为什么要保持它们尽可能的简单，以避免出现错误。你在使用正则表达式时最容易出错的是使用了多个空格，例如：
`var re = /foo bar/;`
在这个正则表达式中，很难断定想要匹配多少个空格。最好是只使用一个空格，然后指定需要多少个，例如：`var re = /foo {3}bar/;` 。这就非常清楚地知道需要匹配 3 个空格。

#### Rule Details

该规则禁止在正则表达式字面量中出现多个空格。

> **错误 代码示例**：

```
/*eslint no-regex-spaces: "error"*/

var re = /foo   bar/;
var re = new RegExp("foo   bar");
```

> **正确 代码示例**：

```
/*eslint no-regex-spaces: "error"*/

var re = /foo {3}bar/;
var re = new RegExp("foo {3}bar");
```

### 25. no-sparse-arrays (禁用稀疏数组)

稀疏数组包括很多空位置，经常是由于在数组字面量中使用多个逗号造成的，例如：
` var items = [,,];`
在这个例子中，item 数组的 length 为 2，实际上，items[0] 或 items[1]并没有值。数组中只有逗号是有效的，再加上 length 被设置，没有实际的值被设置，这些情况让很多开发者对稀疏数组感到困惑。考虑下面的情况：

```
var colors = [ "red",, "blue" ];
```

在这个例子中，colors 数值的 length 是 3。但是否是开发者想让数组中间出现一个空元素？或者只是一个书写错误？

#### Rule Details

该规则禁止使用稀疏数组，也就是逗号之前没有任何元素的数组。该规则不适用于紧随最后一个元素的拖尾逗号的情况。

> **错误 代码示例**：

```
/*eslint no-sparse-arrays: "error"*/

var items = [,];
var colors = [ "red",, "blue" ];
```

> **正确 代码示例**：

```
/*eslint no-sparse-arrays: "error"*/

var items = [];
var items = new Array(23);

// trailing comma (after the last element) is not a problem
var colors = [ "red", "blue", ];
```

### 26. no-unexpected-multiline (禁止使用令人困惑的多行表达式)

在 JavaScript 中，分号通常是可选的，因为会自动插入分号（ASI)。你可以使用 semi 规则要求或禁止分号。

换行不结束语句，书写错误遗漏了分号，这些异常会导致两个不相干的连续的行被解释为一个表达式。特别是对于一个没有分号的代码风格，读者可能会忽略这些错误。尽管语法上是正确的，代码执行时可能会抛出异常。

ASI 的规则是相对简单的：正如 Isaac Schlueter 曾经描述的那样，一个 \n 字符总是一个语句的结尾(像分号一样)，除非下面之一为真：

-   该语句有一个没有闭合的括号，数组字面量或对象字面量或其他某种方式，不是有效结束一个语句的方式。（比如，以 . 或 , 结尾）
-   该行是 -- 或 ++（在这种情况下它将减量/增量的下一个标记）
-   它是个 for()、while()、do、if() 或 else，并且没有 {
-   下一行以 [、(、+、\*、/、-、,、. 或一些其它在单个表达式中两个标记之间的二元操作符。

#### Rule Details

该规则禁止使用令人困惑的多行表达式。

> **错误 代码示例**：

```
/*eslint no-unexpected-multiline: "error"*/

var foo = bar
(1 || 2).baz();

var hello = 'world'
[1, 2, 3].forEach(addNumber);

let x = function() {}
`hello`

let x = function() {}
x
`hello`

let x = foo
/regex/g.test(bar)
```

> **正确 代码示例**：

```
/*eslint no-unexpected-multiline: "error"*/

var foo = bar;
(1 || 2).baz();

var foo = bar
;(1 || 2).baz()

var hello = 'world';
[1, 2, 3].forEach(addNumber);

var hello = 'world'
void [1, 2, 3].forEach(addNumber);

let x = function() {};
`hello`

let tag = function() {}
tag `hello`
```

#### When Not To Use It

如果你有信心你不会意外地引入这样的代码，你可以关闭此规则。

### 27. no-unreachable (禁止在 return、throw、continue 和 break 语句后出现不可达代码)

因为 return、throw、continue 和 break 语句无条件地退出代码块，其之后的任何语句都不会被执行。不可达语句通常是个错误。例如：

```
function fn() {
    x = 1;
    return x;
    x = 3; // this will never execute, i.e unreachable
}
```

#### Rule Details

该规则禁止在 return、throw、continue 和 break 语句后出现不可达代码。

> **错误 代码示例**：

```
/*eslint no-unreachable: "error"*/

function foo() {
    return true;
    console.log("done");
}

function bar() {
    throw new Error("Oops!");
    console.log("done");
}

while(value) {
    break;
    console.log("done");
}

throw new Error("Oops!");
console.log("done");

function baz() {
    if (Math.random() < 0.5) {
        return;
    } else {
        throw new Error();
    }
    console.log("done");
}

for (;;) {}
console.log("done");
```

> **正确 代码示例**, 下面例子中有的是因为 JavaScript 函数和变量提升：

```
/*eslint no-unreachable: "error"*/

function foo() {
    return bar();
    function bar() {
        return 1;
    }
}

function bar() {
    return x;
    var x;
}

switch (foo) {
    case 1:
        break;
        var x;
}
```

### 28. no-unsafe-finally (禁止在 finally 语句块中出现控制流语句)

JavaScript 暂停 try 和 catch 语句块中的控制流语句，直到 finally 语句块执行完毕。所以，当 return、throw、break 和 continue 出现在 finally 中时， try 和 catch 语句块中的控制流语句将被覆盖，这被认为是意外的行为。比如：

```
// We expect this function to return 1;
(() => {
    try {
        return 1; // 1 is returned but suspended until finally block ends
    } catch(err) {
        return 2;
    } finally {
        return 3; // 3 is returned before 1, which we did not expect
    }
})();

// > 3
```

```
// We expect this function to throw an error, then return
(() => {
    try {
        throw new Error("Try"); // error is thrown but suspended until finally block ends
    } finally {
        return 3; // 3 is returned before the error is thrown, which we did not expect
    }
})();

// > 3
```

```
// We expect this function to throw Try(...) error from the catch block
(() => {
    try {
        throw new Error("Try")
    } catch(err) {
        throw err; // The error thrown from try block is caught and rethrown
    } finally {
        throw new Error("Finally"); // Finally(...) is thrown, which we did not expect
    }
})();

// > Uncaught Error: Finally(...)
```

#### Rule Details

该规则禁止在 finally 语句块中出现 return、throw、break 和 continue 语句。它允许间接使用，比如在 function 或 class 的定义中。

> **错误 代码示例**：

```
/*eslint no-unsafe-finally: "error"*/
let foo = function() {
    try {
        return 1;
    } catch(err) {
        return 2;
    } finally {
        return 3;
    }
};


/*或者*/
/*eslint no-unsafe-finally: "error"*/
let foo = function() {
    try {
        return 1;
    } catch(err) {
        return 2;
    } finally {
        throw new Error;
    }
};
```

> **正确 代码示例**：

```
/*eslint no-unsafe-finally: "error"*/
let foo = function() {
    try {
        return 1;
    } catch(err) {
        return 2;
    } finally {
        console.log("hola!");
    }
};

/*或者*/
/*eslint no-unsafe-finally: "error"*/
let foo = function() {
    try {
        return 1;
    } catch(err) {
        return 2;
    } finally {
        let a = function() {
            return "hola!";
        }
    }
};

/*或者*/
/*eslint no-unsafe-finally: "error"*/
let foo = function(a) {
    try {
        return 1;
    } catch(err) {
        return 2;
    } finally {
        switch(a) {
            case 1: {
                console.log("hola!")
                break;
            }
        }
    }
};
```

### 29. no-unsafe-negation (禁止对关系运算符的左操作数使用否定操作符 )

开发人员可能会把 -(a + b) 写错成 -a + b 来表示一个负数，也可能会把 !(key in object) 错写成 !key in object 来测试一个键是否在对象中。类似的情况也有 !obj instanceof Ctor。

#### Rule Details

该规则禁止对关系运算符的左操作数使用否定操作符。

关系运算符有：

-   in 运算符；
-   instanceof 运算符；

> **错误 代码示例**：

```
/*eslint no-unsafe-negation: "error"*/

if (!key in object) {
    // operator precedence makes it equivalent to (!key) in object
    // and type conversion makes it equivalent to (key ? "false" : "true") in object
}

if (!obj instanceof Ctor) {
    // operator precedence makes it equivalent to (!obj) instanceof Ctor
    // and it equivalent to always false since boolean values are not objects.
}
```

> **正确 代码示例**：

```
/*eslint no-unsafe-negation: "error"*/

if (!(key in object)) {
    // key is not in object
}

if (!(obj instanceof Ctor)) {
    // obj is not an instance of Ctor
}

if(("" + !key) in object) {
    // make operator precedence and type conversion explicit
    // in a rare situation when that is the intended meaning
}
```

### 30. require-atomic-updates (禁止由于 await 或 yield 的使用而可能导致出现竞态条件的赋值。)

在编写异步代码时，可能会产生细微的竞争条件错误。考虑下面的例子：

```
let totalLength = 0;

async function addLengthOfSinglePage(pageNum) {
  totalLength += await getPageLength(pageNum);
}

Promise.all([addLengthOfSinglePage(1), addLengthOfSinglePage(2)]).then(() => {
  console.log('The combined length of both pages is', totalLength);
});
```

这段代码看起来将对调用 getPageLength(1) 和 getPageLength(2) 的结果进行求和，但实际上，totalLength 的最终值仅为两个页面中的一个页面的长度。错误在语句 totalLength += await getPageLength(pageNum); 中。该语句首先读取 totalLength 的初始值，然后调用 getPageLength(pageNum) ，并等待该 Promise 完成。最后，它将 totalLength 的值设置为 waiting getPageLength(pageNum) 和 totalLength 的 初始 值的和。如果在 getPageLength(pageNum) Promise 处于 pending 状态期间，在单独的函数调用中更新了 totalLength 变量，那么更新将会丢失，因为新值被覆盖而不被读取。

解决这个问题的一种方法是**确保 totalLength 在更新的同时被读取**，如下所示:

```
async function addLengthOfSinglePage(pageNum) {
  const lengthOfThisPage = await getPageLength(pageNum);

  totalLength += lengthOfThisPage;
}
```

另一个解决方案是**完全避免使用可变变量引用**：

```
Promise.all([getPageLength(1), getPageLength(2)]).then(pageLengths => {
  const totalLength = pageLengths.reduce((accumulator, length) => accumulator + length, 0);

  console.log('The combined length of both pages is', totalLength);
});
```

#### Rule Details

这条规则的目的是报告下列条件为 true 时的情况,即：给变量或属性赋值的：

-   变量或属性根据其旧值重新分配到新值。
-   yield 或 await 表达式在读取旧值之后和设置新值之前中断赋值。
-   规则不能很容易地验证赋值是否安全（例如，如果赋值的变量是本地的，并且在函数暂停时不能从其他任何地方读取）。

> **错误 代码示例**：

```
/* eslint require-atomic-updates: error */

let result;
async function foo() {
  result += await somethingElse;

  result = result + await somethingElse;

  result = result + doSomething(await somethingElse);
}

function* bar() {
  result += yield;

  result = result + (yield somethingElse);

  result = result + doSomething(yield somethingElse);
}
```

> **正确 代码示例**：

```
/* eslint require-atomic-updates: error */

let result;
async function foo() {
  result = await somethingElse + result;  //这和下面一条是相等的。

  let tmp = await somethingElse;
  result += tmp;

  let localVariable = 0;
  localVariable += await somethingElse;
}

function* bar() {
  result += yield;

  result = (yield somethingElse) + result;

  result = doSomething(yield somethingElse, result);
}
```

### 31. use-isnan (要求调用 isNaN()检查 NaN)

在 JavaScript 中，NaN 是 Number 类型的一个特殊值。它被用来表示非数值，这里的数值是指在 IEEE 浮点数算术标准中定义的双精度 64 位格式的值。
因为在 JavaScript 中 NaN 独特之处在于它不等于任何值，包括它本身，与 NaN 进行比较的结果是令人困惑的：

```
NaN !== NaN or NaN != NaN evaluate to true
```

因此，可以使用 Number.isNaN() 或 全局的 isNaN() 函数来测试一个值是否是 NaN。

#### Rule Details

该规则禁止与 ‘NaN’ 的比较。

> **错误 代码示例**：

```
/*eslint use-isnan: "error"*/

if (foo == NaN) {
    // ...
}

if (foo != NaN) {
    // ...
}
```

> **正确 代码示例**：

```
/*eslint use-isnan: "error"*/

if (isNaN(foo)) {
    // ...
}

if (!isNaN(foo)) {
    // ...
}
```

### 32. valid-typeof (强制 typeof 表达式与有效的字符串进行比较)

对于绝大多数用例而言，typeof 操作符的结果是以下字符串字面量中的一个："undefined"、"object"、"boolean"、"number"、"string"、"function"、"symbol" 和 "bigint"。把 typeof 操作符的结果与其它字符串进行比较，通常是个书写错误。

#### Rule Details

该规则强制 typeof 表达式与有效的字符串进行比较。

该规则有一个对象选项：

-   "requireStringLiterals": true 要求 typeof 表达式只与字符串字面量或其它 typeof 表达式 进行比较，禁止与其它值进行比较。

> **错误 代码示例**：

```
/*eslint valid-typeof: "error"*/

typeof foo === "strnig"
typeof foo == "undefimed"
typeof bar != "nunber"
typeof bar !== "fucntion"
```

> **正确 代码示例**：

```
/*eslint valid-typeof: "error"*/

typeof foo === "string"
typeof bar == "undefined"
typeof foo === baz
typeof bar === typeof qux
```

> **选项 { "requireStringLiterals": true } 的 错误 代码示例**：

```
typeof foo === undefined
typeof bar == Object
typeof baz === "strnig"
typeof qux === "some invalid type"
typeof baz === anotherVariable
typeof foo == 5
```

> **选项 { "requireStringLiterals": true } 的 正确 代码示例**：

```
typeof foo === "undefined"
typeof bar == "object"
typeof baz === "string"
typeof bar === typeof qux
```

## 以下是 ESLint Rules 中关于最佳实践的部分：

### 33. no-case-declarations (不允许在 case 子句中使用词法声明)

该规则禁止词法声明 (let、const、function 和 class) 出现在 case 或 default 子句中。原因是，词法声明在整个 switch 语句块中是可见的，但是它只有在运行到它定义的 case 语句时，才会进行初始化操作。

为了保证词法声明语句只在当前 case 语句中有效，将你子句用 { } 包裹在块中。

#### Rule Details

该规则旨在避免访问未经初始化的词法绑定以及跨 case 语句访问被提升的函数。

> **错误 代码示例**：

```
/*eslint no-case-declarations: "error"*/
/*eslint-env es6*/

switch (foo) {
    case 1:
        let x = 1;
        break;
    case 2:
        const y = 2;
        break;
    case 3:
        function f() {}
        break;
    default:
        class C {}
}
```

> **正确 代码示例**：

```
/*eslint no-case-declarations: "error"*/
/*eslint-env es6*/

// Declarations outside switch-statements are valid
const a = 0;

switch (foo) {
    // The following case clauses are wrapped into blocks using brackets
    case 1: {
        let x = 1;
        break;
    }
    case 2: {
        const y = 2;
        break;
    }
    case 3: {
        function f() {}
        break;
    }
    case 4:
        // Declarations using var without brackets are valid due to function-scope hoisting
        var z = 4;
        break;
    default: {
        class C {}
    }
}
```

### 34. no-empty-pattern (禁止使用空解构模式)

当使用解构赋值时，可能创建了一个不起作用的模式。把空的花括号放在嵌入的对象的解构模式右边时，就会产生这种情况，例如：

```
// doesn't create any variables
var {a: {}} = foo;
```

在以上代码中，没有创建新的变量，因为 a 只是一个辅助位置，而 {} 将包含创建的变量，例如：

```
// creates variable b
var {a: { b }} = foo;
```

在另一种情况下，作者本来打算使用一个默认值，却错写成空对象，例如：

```
// creates variable a
var {a = {}} = foo;
```

默认值模式和解构赋值模式直接的区别是微妙的，因为空模式看起来像是一个对象字面量。

#### Rule Details

此规则目的在于标记出在解构对象和数组中的任何的空模式，每当遇到一个这样的空模式，该规则就会报告一个问题。

> **错误 代码示例**：

```
/*eslint no-empty-pattern: "error"*/

var {} = foo;
var [] = foo;
var {a: {}} = foo;
var {a: []} = foo;
function foo({}) {}
function foo([]) {}
function foo({a: {}}) {}
function foo({a: []}) {}
```

> **正确 代码示例**：

```
/*eslint no-empty-pattern: "error"*/

var {a = {}} = foo;
var {a = []} = foo;
function foo({a = {}}) {}
function foo({a = []}) {}
```

### 35. no-fallthrough (禁止 case 语句落空)

在 JavaScript 中，switch 语句是一种比较容易出错的结构，在某种程度上这要归功于 case 的落空能力。比如：

```
switch(foo) {
    case 1:
        doSomething();

    case 2:
        doSomethingElse();
}
```

在这个例子中，如果 foo 值为 1，两个 case 语句都会执行。你可以使用 break 阻止这种情况，例如以下例子：

```
switch(foo) {
    case 1:
        doSomething();
        break;

    case 2:
        doSomethingElse();
}
```

当你不想要落空时是没有问题的，但是，如果落空是有意为之呢，没有办法来表明这一点。使用匹配 /falls?\s?through/i 的正则表达式的注释来表明落空是有意为之的，，被认为是一个最佳实际。如下:

```
switch(foo) {
    case 1:
        doSomething();
        // falls through

    case 2:
        doSomethingElse();
}

switch(foo) {
    case 1:
        doSomething();
        // fall through

    case 2:
        doSomethingElse();
}

switch(foo) {
    case 1:
        doSomething();
        // fallsthrough

    case 2:
        doSomethingElse();
}
```

在这个例子中，不会再引起困惑。很明显，第一个 case 的意思是要落空到第二个 case。

#### Rule Details

该规则旨在消除非故意 case 落空行为。因此，它会标记处没有使用注释标明的落空情况。

> **错误 代码示例**：

```
/*eslint no-fallthrough: "error"*/

switch(foo) {
    case 1:
        doSomething();

    case 2:
        doSomething();
}
```

> **正确 代码示例**：

```
/*eslint no-fallthrough: "error"*/

switch(foo) {
    case 1:
        doSomething();
        break;

    case 2:
        doSomething();
}

function bar(foo) {
    switch(foo) {
        case 1:
            doSomething();
            return;

        case 2:
            doSomething();
    }
}

switch(foo) {
    case 1:
        doSomething();
        throw new Error("Boo!");

    case 2:
        doSomething();
}

switch(foo) {
    case 1:
    case 2:
        doSomething();
}

switch(foo) {
    case 1:
        doSomething();
        // falls through

    case 2:
        doSomething();
}
```

#### 个人建议：少用让 switch case 落空的写法, 容易记不住；

### 36. no-global-assign (禁止对原生对象或只读的全局对象进行赋值)

JavaScript 环境包含很多内置的全局变量，比如浏览器环境的 window 和 Node.js 中的 process。在几乎所有情况下，你都不希望给全局变量赋值，因为这样做可能会到导致无法访问到重要的功能。例如，你可能不想在浏览器代码中这样做：`window = {};` ；

虽然像 window 这样的例子很明显，但是 JavaScript 环境还提供了数百个内置全局对象。很难知道你是否对一个去全局变量进行了赋值。

#### Rule Details

该规则禁止修改只读的全局变量。

```
{
    "globals": {
        "var2": "readonly"
    }
}
```

> 重温以下知识：
> 要在配置文件中配置全局变量，请将 globals 配置属性设置为一个对象，该对象包含以你希望使用的每个全局变量。**对于每个全局变量键，将对应的值设置为 "writable" 以允许重写变量，或 "readonly" 不允许重写变量。**
> **可以使用字符串 "off" 禁用全局变量。**
> 例如，在大多数 ES2015 全局变量可用但 Promise 不可用的环境中，你可以使用以下配置:

```
{
    "env": {
        "es6": true
    },
    "globals": {
        "Promise": "off",
        "var1": "writable",
        "var2": "readonly"
    }
}
```

在这个例子中 var1 允许被重写，var2 不允许被重写， Promise 不可用。

> **错误 代码示例**：

```
/*eslint no-global-assign: "error"*/

Object = null
undefined = 1


/*eslint no-global-assign: "error"*/
/*eslint-env browser*/

window = {}
length = 1
top = 1


/*eslint no-global-assign: "error"*/
/*globals a:false*/

a = 1
```

> **正确 代码示例**：

```
/*eslint no-global-assign: "error"*/

a = 1
var b = 1
b = 2


/*eslint no-global-assign: "error"*/
/*eslint-env browser*/

onload = function() {}


/*eslint no-global-assign: "error"*/
/*globals a:true*/

a = 1
```

#### Options

该规则接受一个 exceptions 选项，可以用来指定允许进行赋值的内置对象列表，
对该规则的配置举例如下：

```
{
    "rules": {
        "no-global-assign": ["error", {"exceptions": ["Object"]}]
    }
}
```

### 37. no-octal (禁用八进制字面量)

八进制自面量是指那些以 0 开始的数字，比如：

```
var num = 071;      // 57 ，57是十进制数
```

在 JavaScript 代码中，八进制的前导数字零作为其标志一致是导致混淆和错误的来源，ECMAScript 5 已经弃用了八进制字面量。

#### Rule Details

该规则禁用八进制字面量。如果 ESLint 是在严格模式下解析代码，解析器（而不是该规则）会报告错误。

> **错误 代码示例**：

```
/*eslint no-octal: "error"*/

var num = 071;
var result = 5 + 07;
```

> **正确 代码示例**：

```
/*eslint no-octal: "error"*/

var num  = "071";
```

### 38. no-redeclare (禁止重新声明变量)

在 JavaScript 中，使用 var 可以对同一个变量再次声明。这会使变量实际声明和定义的位置混乱不堪。

#### Rule Details

此规则目旨在消除同一作用域中多次声明同一变量。

> **错误 代码示例**：

```
/*eslint no-redeclare: "error"*/

var a = 3;
var a = 10;
```

> **正确 代码示例**：

```
/*eslint no-redeclare: "error"*/

var a = 3;
// ...
a = 10;
```

#### Options

该规则有一个选项参数，是个对象，该对象有个布尔属性为 "builtinGlobals"。默认为 true。
如果设置为 true，该规则也会检查全局内建对象，比如 Object、Array、Number…
"builtinGlobals" 选项将会在全局范围检查被重新声明的内置全局变量。

> **选项 { "builtinGlobals": true } 的错误 代码示例**：

```
/*eslint no-redeclare: ["error", { "builtinGlobals": true }]*/

var Object = 0;
```

> **在 browser 环境下，选项 {"builtinGlobals": true} 的错误 代码示例**：

```
/*eslint no-redeclare: ["error", { "builtinGlobals": true }]*/
/*eslint-env browser*/

var top = 0;
```

browser 环境有很多内建的全局变量（例如，top）。一些内建的全局变量不能被重新声明。
注意，当使用 node 或 commonjs 环境 (或 ecmaFeatures.globalReturn，如果使用默认解析器)时，则程序的最大作用域不是实际的全局作用域，而是一个模块作用域。当出现这种情况时，声明一个以内置的全局变量命令的变量，不算是重声明，只是遮蔽了全局变量。在这种情况下，应该使用 no-shadow 规则的 "builtinGlobals" 选项。

### 39. no-self-assign (禁止自身赋值)

自身赋值不起任何作用，可能是由于不完整的重构造成的错误。也表明你的工作还没做完。

```
foo = foo;
[bar, baz] = [bar, qiz];
```

#### Rule Details

该规则旨在消除自身赋值的情况。

> **错误 代码示例**：

```
/*eslint no-self-assign: "error"*/

foo = foo;

[a, b] = [a, b];

[a, ...b] = [x, ...b];

({a, b} = {a, x});
```

> **正确 代码示例**：

```
/*eslint no-self-assign: "error"*/

foo = bar;
[a, b] = [b, a];

// This pattern is warned by the `no-use-before-define` rule.
let foo = foo;

// The default values have an effect.
[foo = 1] = [foo];

// non-self-assignments with properties.
obj.a = obj.b;
obj.a.b = obj.c.b;
obj.a.b = obj.a.c;
obj[a] = obj["a"];

// This ignores if there is a function call.
obj.a().b = obj.a().b;
a().b = a().b;

// Known limitation: this does not support computed properties except single literal or single identifier.
obj[a + b] = obj[a + b];
obj["a" + "b"] = obj["a" + "b"];
```

#### Options

该规则也有可以检查属性的选项: props - 如果为 true，no-self-assign 规则将对属性的自我赋值发出警告。默认为 true.

```
{
    "no-self-assign": ["error", {"props": true}]
}
```

> **选项 { "props": false } 的 正确 代码示例**：

```
/*eslint no-self-assign: ["error", {"props": false}]*/

// self-assignments with properties.
obj.a = obj.a;
obj.a.b = obj.a.b;
obj["a"] = obj["a"];
obj[a] = obj[a];
```

### 40. no-unused-labels (禁用未使用过的标签)

命令行中的 --fix 选项可以自动修复一些该规则报告的问题。

关于 label 的用法，参考： https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/label

只声明却没有使用的 label 可能是由于不完全的重构造成的错误。

```
OUTER_LOOP:
for (const student of students) {
    if (checkScores(student.scores)) {
        continue;
    }
    doSomething(student);
}
```

在这个例子中，可能是忘记了移除 OUTER_LOOP: 。这样的 label 不仅占据代码空间，而且会使读者感到迷惑。

#### Rule Details

该规则旨在消除未使用过的 label。

> **错误 代码示例**：

```
/*eslint no-unused-labels: "error"*/

A: var foo = 0;

B: {
    foo();
}

C:
for (let i = 0; i < 10; ++i) {
    foo();
}
```

> **正确 代码示例**：

```
/*eslint no-unused-labels: "error"*/

A: {
    if (foo()) {
        break A;
    }
    bar();
}

B:
for (let i = 0; i < 10; ++i) {
    if (foo()) {
        break B;
    }
    bar();
}
```

### 41. no-useless-catch (禁止不必要的 catch 子句)

只重新抛出原始错误的 catch 子句是冗余的，对程序的运行时行为没有影响。这些冗余子句可能会导致混乱和代码膨胀，所以最好不要使用这些不必要的 catch 子句。

#### Rule Details

此规则报告只 throw 已捕获过的错误的 catch 子句。

> **错误 代码示例**：

```
/*eslint no-useless-catch: "error"*/

try {
  doSomethingThatMightThrow();
} catch (e) {
  throw e;
}

try {
  doSomethingThatMightThrow();
} catch (e) {
  throw e;
} finally {
  cleanUp();
}
```

> **正确 代码示例**：

```
/*eslint no-useless-catch: "error"*/

try {
  doSomethingThatMightThrow();
} catch (e) {
  doSomethingBeforeRethrow();
  throw e;
}

try {
  doSomethingThatMightThrow();
} catch (e) {
  handleError(e);
}
```

### 42. no-useless-catch (禁止不必要的 catch 子句)

只重新抛出原始错误的 catch 子句是冗余的，对程序的运行时行为没有影响。这些冗余子句可能会导致混乱和代码膨胀，所以最好不要使用这些不必要的 catch 子句。

#### Rule Details

此规则报告只 throw 已捕获过的错误的 catch 子句。

> **错误 代码示例**：

```
/*eslint no-useless-catch: "error"*/

try {
  doSomethingThatMightThrow();
} catch (e) {
  throw e;
}

try {
  doSomethingThatMightThrow();
} catch (e) {
  throw e;
} finally {
  cleanUp();
}
```

> **正确 代码示例**：

```
/*eslint no-useless-catch: "error"*/

try {
  doSomethingThatMightThrow();
} catch (e) {
  doSomethingBeforeRethrow();
  throw e;
}

try {
  doSomethingThatMightThrow();
} catch (e) {
  handleError(e);
}
```

### 43. no-useless-escape (禁用不必要的转义)

对字符串、模板字面量和正则表达式中的常规字符进行的转义，不会对结果产生任何影响，例如：

```
let foo = "hol\a"; // > foo = "hola"
let bar = `${foo}\!`; // > bar = "hola!"
let baz = /\:/ // same functionality with /:/
```

#### Rule Details

该规则标记在不改变代码行为的情况下可以安全移除的转义。

> **错误 代码示例**：

```
/*eslint no-useless-escape: "error"*/

"\'";
'\"';
"\#";
"\e";
`\"`;
`\"${foo}\"`;
`\#{foo}`;
/\!/;
/\@/;

```

> **正确 代码示例**：

```
/*eslint no-useless-escape: "error"*/

"\"";
'\'';
"\x12";
"\u00a9";
"\371";
"xs\u2111";
`\``;
`\${${foo}}`;
`$\{${foo}}`;
/\\/g;
/\t/g;
/\w\$\*\^\./;
```

### 44. no-with (禁用 with 语句)

with 语句是潜在的问题，因为它会在当前的域中增加对象成员，使得区分实际块中的变量指的是什么变的不可能。

#### Rule Details

此规则目的在于排除 with 语句。
如果 ESLint 在严格模式下解析代码，解析器（不是该规则）将报告这样的错误。

> **错误 代码示例**：

```
/*eslint no-with: "error"*/

with (point) {
    r = Math.sqrt(x * x + y * y); // is r a member of point?
}
```

> **正确 代码示例**：

```
/*eslint no-with: "error"*/
/*eslint-env es6*/

const r = ({x, y}) => Math.sqrt(x * x + y * y);
```

### 45. no-delete-var (禁止删除变量)

delete 的目的是删除对象的属性。使用 delete 操作删除一个变量可能会导致意外情况发生。

#### Rule Details

该规则禁止对变量使用 delete 操作符。
如果 ESLint 是在严格模式下解析代码，解析器（而不是该规则）会报告错误。

> **错误 代码示例**：

```
/*eslint no-delete-var: "error"*/

var x;
delete x;
```

### 46. no-shadow-restricted-names (关键字不能被遮蔽)

ES5 §15.1.1 中全局对象的属性值 (NaN、Infinity、undefined)和严格模式下被限定的标识符 eval、arguments 在 JavaScript 中被认为是受限制的名称。将它们定义为其他含义可能会产生意想不到的结果，并使阅读代码的其他人感到困惑。比如：

```
var undefined = "foo";
```

> **错误 代码示例**：

```
/*eslint no-shadow-restricted-names: "error"*/

function NaN(){}

!function(Infinity){};

var undefined = 5;

try {} catch(eval){}
```

> **正确 代码示例**：

```
/*eslint no-shadow-restricted-names: "error"*/

var Object;

function f(a, b){}

// Exception: `undefined` may be shadowed if the variable is never assigned a value.
var undefined;
```

### 47. no-undef (禁用未声明的变量)

此规则可帮助你定位由变量漏写、参数名漏写和意外的隐式全局变量声明所导致的潜在引用错误（比如，在 for 循环语句中初始化变量忘写 var 关键字）

#### Rule Details

对任何未声明的变量的引用都会引起一个警告，除非显式地在 /_global ..._/ 注释中指定，或在 globals key in the configuration file 中指定。另一个常见的用例是，你有意使用定义在其他地方的全局变量(例如来自 HTML 的脚本)。

> **错误 代码示例**：

```
/*eslint no-undef: "error"*/

var a = someFunction();
b = 10;
```

> **有 global 声明时，该规则的 正确 代码示例**：

```
/*global someFunction b:true*/
/*eslint no-undef: "error"*/

var a = someFunction();
b = 10;

// 在/*global */ 中的 b:true 表明对 b 继续赋值是正确的。
```

> **有 global 声明时，该规则的 错误 代码示例**：

```
/*global b*/
/*eslint no-undef: "error"*/

b = 10;

//  **默认情况下，/*global */ 中声明的变量是只读的，因此对其进行赋值是错误的。**
```

#### Options

该规则也有 typeof 选项，默认值为 false。当值为 true，将对 typeof 检查中用到的变量发出警告。

> **默认选项 { "typeof": false } 的 正确 代码示例**:

```
/*eslint no-undef: "error"*/

if (typeof UndefinedIdentifier === "undefined") {
    // do something ...
}

// 如果想阻止在 typeof 运算中有未申明的变量导致的警告，可以用此项。
```

> **选项 { "typeof": true } 的 错误 代码示例**：

```
/*eslint no-undef: ["error", { "typeof": true }] */

if(typeof a === "string"){}
```

> **有 global 声明时，选项 { "typeof": true } 的 正确 代码示例**：

```
/*global a*/
/*eslint no-undef: ["error", { "typeof": true }] */

if(typeof a === "string"){}
```

ESlint 提供了预定义流行类库和运行时环境暴露的全局变量的快捷方式。该规则支持这些环境，如 指定 Environments 中列出的。使用如下：

> **browser 环境下的 正确 代码示例**：

```
/*eslint no-undef: "error"*/
/*eslint-env browser*/

setTimeout(function() {
    alert("Hello");
});
```

> **node 环境下的 正确 代码示例**：

```
/*eslint no-undef: "error"*/
/*eslint-env node*/

var fs = require("fs");
module.exports = function() {
    console.log(fs);
};
```

// 编辑完成，日期： 2021/7/7
